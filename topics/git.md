## Введение

Git для системного аналитика нужен не меньше, чем для разработчика. Аналитик работает с требованиями, API-спецификациями, схемами БД, BPMN/UML-диаграммами и эксплуатационной документацией, а всё это изменяется итеративно и требует прозрачной истории. Git позволяет управлять этой историей, согласовывать изменения через review и снижать риск потери знаний.

## Основные концепции

### Что важно понимать аналитику

* **Репозиторий:** единое место хранения артефактов проекта: `docs/`, `api/`, `db/`, `diagrams/`.
* **Коммит:** логически завершённое изменение. Для аналитики это часто "одно бизнес-изменение = один коммит".
* **Ветка:** изоляция работы по задаче. Стандартно: `feature/`, `bugfix/`, `hotfix/`.
* **Pull Request / Merge Request:** основной канал согласования изменений между аналитиком, разработкой и тестированием.
* **Merge и Rebase:** два способа интеграции изменений. Для командной прозрачности обычно проще `merge`; для линейной истории полезен `rebase`.
* **Теги:** удобны для фиксации "срезов знаний" под релизы (`v1.8.0-docs`).

### Базовый рабочий цикл аналитика

```bash
git checkout -b feature/SA-142-payment-limits
# изменить требования/спецификации
git add .
git commit -m "SA-142: update payment limits and validation rules"
git push -u origin feature/SA-142-payment-limits
```

После этого создаётся PR/MR, где команда проверяет формулировки, совместимость API и влияние на БД.

## Git в аналитических артефактах

### Требования и документация

Лучше хранить документы в текстовых форматах (`md`, `adoc`, `json`, `yaml`), а не только в бинарных файлах. Это даёт:

* наглядный `diff`;
* простое ревью построчно;
* возможность автоматических проверок.

### API-контракты

OpenAPI/AsyncAPI-спецификации удобно хранить рядом с кодом. Аналитик может:

* менять контракт в ветке задачи;
* запускать lint/валидацию;
* обсуждать изменения через PR.

### SQL и миграции

Даже если аналитик не пишет production SQL, в Git стоит хранить:

* скрипты проверки гипотез;
* миграции схемы;
* seed-данные для стендов.

Это помогает воспроизводить решения и обсуждать изменения с DBA/разработкой.

## Практические примеры

### Пример 1: правка требования с трассируемостью

Структура:

```text
docs/
  requirements/
    payments.md
```

Команды:

```bash
git checkout -b feature/SA-210-3ds2
git add docs/requirements/payments.md
git commit -m "SA-210: add 3DS2 fallback requirement"
```

В сообщении коммита фиксируется ID задачи, поэтому легко связать изменение с Jira/трекером.

### Пример 2: согласование изменения API

```bash
git checkout -b feature/SA-221-customer-api
git add api/customer/openapi.yaml
git commit -m "SA-221: add customer status and filtering"
git push
```

В PR аналитик добавляет:

* что меняется в контракте;
* обратная совместимость;
* какие сценарии нужно ретестировать.

### Пример 3: разрешение конфликтов в документации

```bash
git checkout feature/SA-221-customer-api
git fetch origin
git merge origin/main
```

Если есть конфликт, аналитик вручную выбирает корректную формулировку, затем:

```bash
git add api/customer/openapi.yaml
git commit -m "SA-221: resolve merge conflict in customer API spec"
```

## Рекомендации по процессу

* Используйте шаблон веток с ID задачи: `feature/SA-123-short-name`.
* Делайте небольшие коммиты, чтобы review было быстрым.
* Согласуйте стиль commit message:
  * `SA-123: verb + scope` (например, `SA-123: clarify refund timeout`).
* Защитите `main`: прямые push должны быть запрещены.
* Для крупных изменений документации создавайте PR-чеклист.

Пример чеклиста для PR аналитика:

* обновлены бизнес-правила;
* синхронизированы API и DB-артефакты;
* добавлены ограничения/ошибки;
* описаны backward compatibility риски.

## Типичные ошибки и как их избежать

* **Большой коммит "на всё сразу":** сложно ревьюить и откатывать.  
  **Решение:** разделять по смыслу и по типу артефактов.
* **Нет связи с задачей:** теряется трассировка решений.  
  **Решение:** включать ID задачи в ветку, коммит и PR.
* **Редактирование напрямую в `main`:** высокий риск конфликтов и регрессий.  
  **Решение:** только ветки и PR/MR.
* **Хранение только в Confluence без Git-копии критичных спецификаций:** сложно управлять версиями.  
  **Решение:** критичные артефакты дублировать в git-репозитории.

## Связь с другими темами

Git тесно связан с темами `DocOps`, `Jira и Confluence`, `Swagger/OpenAPI`, `SQL` и `Мониторинг`. Через Git строится сквозной процесс: от бизнес-требований до поставки изменений и сопровождения.

## Заключение

Для системного аналитика Git - это инструмент управляемости знаний. Он делает требования проверяемыми, изменения прозрачными, а командную работу предсказуемой.
