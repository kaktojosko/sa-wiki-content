## Введение

Агрегатные функции в SQL — это мощный инструмент для анализа данных, хранящихся в реляционных базах данных. Они позволяют выполнять вычисления над набором значений и возвращать одно сводное значение. Эти функции являются неотъемлемой частью языка SQL и широко используются для создания отчетов, анализа данных и принятия бизнес-решений. Без них для получения сводной информации, такой как общая сумма продаж, средний возраст сотрудников или количество товаров на складе, потребовались бы сложные и неэффективные запросы или дополнительная обработка данных на стороне приложения.

Основное преимущество агрегатных функций заключается в их способности обрабатывать большие объемы данных непосредственно на сервере базы данных, что значительно сокращает объем передаваемой информации и ускоряет получение результатов. В этой статье мы подробно рассмотрим пять основных агрегатных функций: `SUM`, `MIN`, `MAX`, `AVG` и `COUNT`, разберем их синтаксис, принципы работы и приведем практические примеры использования.

## Основные концепции

Агрегатные функции работают с группами строк и часто используются в сочетании с предложением `GROUP BY`, которое позволяет разделить строки на группы и применить функцию к каждой группе отдельно. Если `GROUP BY` не указано, функция применяется ко всем строкам, удовлетворяющим условиям запроса.

### SUM() - Сумма значений

Функция `SUM()` вычисляет сумму всех значений в указанном столбце. Она может применяться только к числовым типам данных.

**Синтаксис:**
```sql
SELECT SUM(имя_столбца) FROM имя_таблицы;
```

### MIN() - Минимальное значение

Функция `MIN()` возвращает минимальное значение в указанном столбце. Она может использоваться с числовыми, строковыми и временными типами данных.

**Синтаксис:**
```sql
SELECT MIN(имя_столбца) FROM имя_таблицы;
```

### MAX() - Максимальное значение

Функция `MAX()` возвращает максимальное значение в указанном столбце. Как и `MIN()`, она применима к числовым, строковым и временным типам данных.

**Синтаксис:**
```sql
SELECT MAX(имя_столбца) FROM имя_таблицы;
```

### AVG() - Среднее значение

Функция `AVG()` вычисляет среднее арифметическое всех значений в указанном столбце. Применяется только к числовым типам данных.

**Синтаксис:**
```sql
SELECT AVG(имя_столбца) FROM имя_таблицы;
```

### COUNT() - Количество строк

Функция `COUNT()` подсчитывает количество строк. Существует несколько вариантов ее использования:

* `COUNT(*)`: подсчитывает общее количество строк в таблице или группе.
* `COUNT(имя_столбца)`: подсчитывает количество строк, в которых указанный столбец имеет не-NULL значения.
* `COUNT(DISTINCT имя_столбца)`: подсчитывает количество уникальных не-NULL значений в столбце.

**Синтаксис:**
```sql
SELECT COUNT(*) FROM имя_таблицы;
SELECT COUNT(имя_столбца) FROM имя_таблицы;
SELECT COUNT(DISTINCT имя_столбца) FROM имя_таблицы;
```

## Практические примеры

Для демонстрации работы агрегатных функций создадим таблицу `Employees` (Сотрудники) и `Departments` (Отделы).

**Таблица `Departments`**

| DepartmentID | DepartmentName |
|--------------|----------------|
| 1            | IT             |
| 2            | HR             |
| 3            | Sales          |

**Таблица `Employees`**

| EmployeeID | FirstName | LastName | DepartmentID | Salary   | HireDate   |
|------------|-----------|----------|--------------|----------|------------|
| 1          | Иван      | Иванов   | 1            | 120000   | 2022-01-15 |
| 2          | Петр      | Петров   | 1            | 150000   | 2021-03-20 |
| 3          | Анна      | Сидорова | 3            | 95000    | 2023-05-10 |
| 4          | Елена     | Смирнова | 3            | 110000   | 2022-08-01 |
| 5          | Дмитрий   | Кузнецов | 2            | 80000    | 2023-02-25 |
| 6          | Сергей    | Попов    | 3            | NULL     | 2023-09-01 |


### Пример 1: Общая статистика по зарплатам

Предположим, нам нужно получить общую информацию по зарплатам всех сотрудников: общую сумму, минимальную, максимальную и среднюю зарплату, а также количество сотрудников, у которых указана зарплата.

```sql
SELECT
    SUM(Salary) AS TotalSalary,
    MIN(Salary) AS MinSalary,
    MAX(Salary) AS MaxSalary,
    AVG(Salary) AS AverageSalary,
    COUNT(Salary) AS NumberOfEmployeesWithSalary
FROM Employees;
```

**Результат:**

| TotalSalary | MinSalary | MaxSalary | AverageSalary | NumberOfEmployeesWithSalary |
|-------------|-----------|-----------|---------------|-----------------------------|
| 555000      | 80000     | 150000    | 111000.0000   | 5                           |

Обратите внимание, что `COUNT(Salary)` вернул 5, так как у одного сотрудника (Сергей Попов) зарплата не указана (NULL). Если бы мы использовали `COUNT(*)`, результат был бы 6.

### Пример 2: Статистика по отделам

Теперь усложним задачу и посчитаем статистику по каждому отделу отдельно. Для этого нам понадобится предложение `GROUP BY` и объединение таблиц `Employees` и `Departments`.

```sql
SELECT
    d.DepartmentName,
    COUNT(e.EmployeeID) AS NumberOfEmployees,
    AVG(e.Salary) AS AverageSalary
FROM Employees AS e
JOIN Departments AS d ON e.DepartmentID = d.DepartmentID
GROUP BY d.DepartmentName
ORDER BY AverageSalary DESC;
```

**Результат:**

| DepartmentName | NumberOfEmployees | AverageSalary |
|----------------|-------------------|---------------|
| IT             | 2                 | 135000.0000   |
| Sales          | 3                 | 102500.0000   |
| HR             | 1                 | 80000.0000    |

Этот запрос показывает количество сотрудников и среднюю зарплату в каждом отделе, отсортированные по убыванию средней зарплаты. Мы видим, что IT-отдел имеет самую высокую среднюю зарплату.

### Пример 3: Подсчет уникальных значений

Допустим, мы хотим узнать, сколько уникальных отделов имеют сотрудников с зарплатой выше 100,000.

```sql
SELECT COUNT(DISTINCT DepartmentID)
FROM Employees
WHERE Salary > 100000;
```

**Результат:** 2

В данном случае, это сотрудники из отделов IT (ID 1) и Sales (ID 3). Хотя таких сотрудников трое, уникальных отделов всего два.

## Типичные ошибки и как их избежать

1. **Неправильное использование `COUNT()`:** `COUNT(*)` и `COUNT(имя_столбца)` могут давать разные результаты из-за `NULL` значений. Всегда четко понимайте, что именно вы хотите посчитать: все строки или только строки с не-`NULL` значениями в определенном столбце.
2. **Использование агрегатных функций без `GROUP BY`:** Если в `SELECT` есть и агрегатная функция, и обычный столбец, необходимо использовать `GROUP BY` для этого столбца. Иначе база данных не поймет, как сгруппировать данные..
    * **Неправильно:** `SELECT DepartmentID, COUNT(*) FROM Employees;`   
    * **Правильно:** `SELECT DepartmentID, COUNT(*) FROM Employees GROUP BY DepartmentID;`
3. **Фильтрация с помощью `WHERE` вместо `HAVING`:** Предложение `WHERE` фильтрует строки *до* их группировки и агрегации. Если нужно отфильтровать результат *после* агрегации (например, показать только отделы с более чем 2 сотрудниками), следует использовать `HAVING`.`.
    * **Неправильно:** `SELECT DepartmentName, COUNT(*) FROM ... GROUP BY DepartmentName WHERE COUNT(*) > 2;`    
    * **Правильно:** `SELECT DepartmentName, COUNT(*) FROM ... GROUP BY DepartmentName HAVING COUNT(*) > 2;`
4. **Неправильное использование оконных функций:** Оконные функции (например, `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`) часто используются в сочетании с агрегатными функциями, но их можно использовать и по отдельности. Если вы хотите применить оконную функцию к каждому ряду в результате, не используйте агрегатные функции.

## Связь с другими темами

Агрегатные функции тесно связаны с другими важными концепциями SQL:

* **`GROUP BY`:** Как мы видели, это предложение является ключевым для применения агрегатных функций к подгруппам данных.
* **`HAVING`:** Позволяет фильтровать результаты, полученные с помощью агрегатных функций.
* **Оконные функции (Window Functions):** Это более продвинутая концепция, которая также выполняет вычисления над набором строк, но, в отличие от агрегатных функций, не "схлопывает" строки в одну, а возвращает значение для каждой строки. Например, можно посчитать "скользящее среднее".
* **Подзапросы (Subqueries):** Агрегатные функции часто используются в подзапросах для получения промежуточных значений, которые затем используются в основном запросе.

## Заключение

Агрегатные функции `SUM`, `MIN`, `MAX`, `AVG` и `COUNT` являются фундаментальными строительными блоками для анализа данных в SQL. Они предоставляют простой и эффективный способ извлечения сводной информации из больших наборов данных. Понимание их работы, синтаксиса и правильного использования в сочетании с `GROUP BY` и `HAVING` является критически важным навыком для любого специалиста, работающего с базами данных. Освоив эти функции, вы сможете писать более сложные и осмысленные запросы, превращая сырые данные в ценную информацию. Дальнейшее изучение оконных функций может стать следующим шагом в углублении ваших знаний в области анализа данных с помощью SQL.
